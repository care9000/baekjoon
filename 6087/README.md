# 6087_레이저_통신

- URL: https://www.acmicpc.net/problem/6087

- 출처:데이터를 추가한 사람: [gaelim](https://www.acmicpc.net/user/gaelim)


## 개요

---

구하려는 값: 레이저를 발사하여 다른 레이저와 만나게 거울을 설치 하려고 할때 거울을 설치 할 수 있는 최소 갯수 구하기

 1<=  H, W  <= 100 이고 레이저는 항상 이어질 수 있는 값들만 주어짐.

bfs를 통하여 꺾일때 마다 카운트를 증가 시켜주고 만약 cnt가 visited에 있는 값보다 작으면 pass 크거나 같으면 q( i좌표, j 좌표, dir(방향) , 꺾인횟수) 에 담아 주는 식으로 품 

방향은 3방향 이므로 -1, 0, 1 이렇게 3 방향만 구함

최종적 visited(레이저에서) 담긴값으로 몇번 꺾였는지 값을 계산해줌

## 구현방법

---



bfs로 구현

- 먼저 입력받은 값(string)을 int 값으로 변환(벽은 1, 갈 수 있는 공간은 0, 레이저는 9 로변환 시켜줌)
- bfs를 돌면서 3방향 탐색 좌, 우, 정면(※반대편은 확인 할 필요가 없기 때문에) 꺾인 값만큼을 visited에 있는 값고 비교하여 작으면 q에 넣어주고 크면 넣지 않음. 

## 결과

---

푸는데 총 소요시간 (코딩:1시간 30분) /3 try

1224ms(python 꼴지.)

## 회고##

---

bfs로 푼다는것은 바로 파악함. 하지만 바로 코딩을 하지않고 어떻게 할지에 대해 손코딩을 직접해봄

하고 나서 코딩을 시작하였으며 최대한 하드코딩을 하지 않기 위하여 방향설정도 범위를 생각하여 구현함

그결과 처음엔 틀렸음. 이유를 찾지 못하였지만 잠깐 바람쐬면서 visited에 있는 값과 같을 경우에도 q에 담는다는 것을 깜빡함. 그것을 수정하니 맞춤.

- 이래서 하드코딩을 하면 안되고 최대한 간단히 함수화 하게 하라고 한지 알 거같다. 
- 하지만 아직 정확하게 푸는 능력이 부족하다. 이부분은 진짜 보완해야 할것.
- 메모리 계산 부분 도 부족(메모리 관련 글이나 공부를 해야할 듯.)
- ★손코딩 진짜 중요함 무조건 문제를 푸는 것이 아니라 문제를 파악하고 푸는것이 진짜로 중요함.

