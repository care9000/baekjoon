# 알고리즘스터디_2


## 개요

---



1. 은수는 (1, 1) 지역부터 출발하며, (N, N)지역에 최대한 빨리 도착하는 것이 목표다.

2. 이동장비에는 4칸의 게이지가 있으며, 새로운 지역을 갈 때마다 그곳의 숫자가 queue형식으로 채워진다.

3. 이동장비는 가장 처음 출발할 때의 횟수는 0으로 값은 넣지 않고 이동하고, x(쓰이지않는 빈 값) 가 4개 들어있다.

4. 이동장비에 값이 4개가 채워졌을때 A, B, C코드와 비교하여 일치하는 코드가 있으면 **무조건** 발동한 뒤에 코드를 빈값으로 초기화하고, 일치하지 않으면 유지한 채로 이동한다. 

5. A, B, C의 코드의 이동방식은 다음과 같다.

   - A코드

     (1, 1)의 위치로 이동하며, 코드를 초기화 한 뒤 그곳에 있는 코드를 추가한다.

   - B코드

     (N/2, N/2)의 위치로 이동하며, 코드를 초기화 한 뒤 그곳에 있는 코드를 추가한다.

   - C코드

     코드를 초기화 한 뒤, 다음 1번의 이동에 드는 횟수를 세지 않는다. (코드는 그대로 입력받음)

6. 어떠한 방식으로도 도착 할 수 없거나, 이동 횟수가 100회를 초과하는 작업은 실패로 친다.

7. 성공할 경우엔 최소 이동 횟수를, 실패할 경우에는 -1을 출력한다. 

8. 처음 N이 주어지며, 다음 N개의 줄에 각 땅의 정보가 주어진다.

9. 그 다음 A, B, C의 발동코드 갯수들이 공백으로 주어지며, 다음 A+B+C줄에 발동되는 코드들이 주어진다.

10. 각 코드들은 중복되지 않음이 보장되고, 코드가 작동된 이후의 자리에서 결과를 판단한다.

11. 정답이 되는 이동방법은 여러가지가 있을 수 있다.



## 구현방법

---

bfs를 사용하여 구현하려고 하였다. 

먼저 자신이 가지고 있는코드를 가지고 방문을 한다.

그방문지점에 자신이 가지고 간 코드가 있을 경우에는 q에 담지않고

없을 경우에만 q에 담는다

하지만 담기전에 code를 확인한다. 만약 abc코드중에 일치하는 값이 있게 되면 그코드를 실행한다

요점:visited할떄 자신이 가지고 있는코드가 방문한 적이 있다면 방문 하지 않고 

방문한적이 없다면 그자리에 자신의 코드를 append해줌.



 

## 결과

---

1시간

## 회고

---

비슷한 유형을 풀어봐서 엄청 오래걸리진 않았지만 잔 실수들이 많았다...